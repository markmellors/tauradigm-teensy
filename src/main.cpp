#include <Arduino.h>
#include <Adafruit_SSD1306.h>
#include <Chrono.h>
#include <Encoder.h>
#include <SerialTransfer.h>
#include <Servo.h>
#include <VL53L0X.h>
#include "Wire.h"
#include "teensy_config.h"

extern "C" {
#include "utility/twi.h"  // from Wire library, so we can do bus scanning
}

// #define DEBUG

Servo motorLeft;
Servo motorRight;

struct MotorSpeeds {
    float left;
    float right;
} motorSpeeds;
uint32_t missedMotorMessageCount = 0;

SerialTransfer myTransfer;

int8_t step = 1;

Chrono sendMessage;
Chrono readSensors;
VL53L0X sensor;

float distances[8];
bool activeToFSensors[8];
Encoder encoders[NUM_ENCODERS] = {
    Encoder(TEENSY_PIN_ENC1A, TEENSY_PIN_ENC1B),
    Encoder(TEENSY_PIN_ENC2A, TEENSY_PIN_ENC2B),
    Encoder(TEENSY_PIN_ENC3A, TEENSY_PIN_ENC3B),
    Encoder(TEENSY_PIN_ENC4A, TEENSY_PIN_ENC4B),
    Encoder(TEENSY_PIN_ENC5A, TEENSY_PIN_ENC5B),
    Encoder(TEENSY_PIN_ENC6A, TEENSY_PIN_ENC6B)};

long encoderReadings[NUM_ENCODERS];

#define DISPLAY_ADDRESS 0x3c

Adafruit_SSD1306 display(128, 64);

#define LOGO_HEIGHT   32
#define LOGO_WIDTH    128
static const unsigned char PROGMEM logo_bmp[] =
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x3f, 0xff, 0x80, 0x03, 0x87, 0x07, 0xe0, 0x01, 0xc7, 0x07, 0x00, 0x71, 0xc3, 0x8e, 0x01, 0xc0, 
0x3f, 0xff, 0x80, 0x03, 0xbf, 0x3f, 0xf0, 0x07, 0xf7, 0x07, 0x01, 0xfd, 0xc3, 0xbf, 0x8f, 0xe0, 
0x3f, 0xff, 0x80, 0x03, 0xff, 0x38, 0x78, 0x0f, 0x3f, 0x07, 0x07, 0xcf, 0xc3, 0xf9, 0xde, 0xf0, 
0x00, 0xe0, 0x00, 0x03, 0xe0, 0x00, 0x1c, 0x1c, 0x0f, 0x07, 0x07, 0x07, 0xc3, 0xe0, 0xf0, 0x70, 
0x00, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x1c, 0x1c, 0x0f, 0x07, 0x0e, 0x03, 0xc3, 0xc0, 0xf0, 0x38, 
0x00, 0xe0, 0x00, 0x03, 0x80, 0x00, 0x1c, 0x38, 0x07, 0x07, 0x0e, 0x03, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x00, 0x03, 0x80, 0x07, 0xfc, 0x38, 0x07, 0x07, 0x0c, 0x01, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x1f, 0xe3, 0x80, 0x1f, 0xfc, 0x38, 0x07, 0x07, 0x0c, 0x01, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x1f, 0xe3, 0x80, 0x3c, 0x1c, 0x38, 0x07, 0x07, 0x0c, 0x01, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x00, 0x03, 0x80, 0x70, 0x1c, 0x38, 0x07, 0x07, 0x0c, 0x01, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x00, 0x03, 0x80, 0x70, 0x1c, 0x38, 0x07, 0x07, 0x0e, 0x03, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x00, 0x03, 0x80, 0x70, 0x1c, 0x38, 0x07, 0x07, 0x0e, 0x03, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0xe0, 0x00, 0x03, 0x80, 0x70, 0x3c, 0x1c, 0x0f, 0x07, 0x07, 0x07, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0x70, 0x00, 0x03, 0x80, 0x38, 0x7c, 0x0e, 0x1f, 0x07, 0x07, 0xcf, 0xc3, 0x80, 0xe0, 0x38, 
0x00, 0x7c, 0x00, 0x03, 0x80, 0x3f, 0xfc, 0x07, 0xf7, 0x07, 0x01, 0xfd, 0x83, 0x80, 0xe0, 0x38, 
0x00, 0x1c, 0x00, 0x03, 0x80, 0x0f, 0xdc, 0x03, 0xe7, 0x07, 0x00, 0x71, 0x83, 0x80, 0xe0, 0x38, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void tcaselect(uint8_t i) {
    if (i > 7) {
        return;
    }

    Wire.beginTransmission(TCAADDR);
    Wire.write(1 << i);
    Wire.endTransmission();
}

void setup() {
#ifdef DEBUG
    Serial.begin(115200);
    while (!Serial) {
    };
#endif

    Serial2.begin(1152000);
    while (!Serial2) {
    };

    motorLeft.attach(TEENSY_PIN_DRIVE_LEFT);
    motorRight.attach(TEENSY_PIN_DRIVE_RIGHT);

    myTransfer.begin(Serial2);
    motorSpeeds.left = 0;
    motorSpeeds.right = 0;

    Wire.begin();
    
    if (!display.begin(SSD1306_SWITCHCAPVCC, DISPLAY_ADDRESS)) {
        Serial.println("SSD1306 allocation failed");
        for(;;);
    }

    display.clearDisplay();

    display.drawBitmap(
        (display.width()  - LOGO_WIDTH ) / 2,
        (display.height() - LOGO_HEIGHT) / 2,
        logo_bmp, LOGO_WIDTH, LOGO_HEIGHT, 1
    );
    display.display();
    tcaselect(0);
    for (uint8_t t = 0; t < 8; t++) {
        tcaselect(t);
#ifdef DEBUG
        Serial.print("TCA Port #");
        Serial.println(t);
        sensor.setTimeout(500);
        Serial.print("init sensor: ");
        Serial.println(t);
#endif
        // Start continuous back-to-back mode (take readings as
        // fast as possible).  To use continuous timed mode
        // instead, provide a desired inter-measurement period in
        // ms (e.g. sensor.startContinuous(100)).

        activeToFSensors[t] = sensor.init();

        if (activeToFSensors[t]) {
            sensor.setMeasurementTimingBudget(20000);
            sensor.startContinuous();
#ifdef DEBUG
            Serial.printf("Sensor %d init success", t);
#endif
        } else {
            /*
            TODO What to do to indicate sensor init failure?
            don't attempt to read from failed sensor? show in i2c oled?
            */
#ifdef DEBUG
            Serial.print("Failed to detect and initialize sensor: ");
            Serial.println(t);
            // while (1) {
            // }

#endif
        }
    }
}

void loop() {
    // If the message sending timeout has passed then attempt to read
    // motor speeds and apply them
    if (sendMessage.hasPassed(20)) {
        // restart the timeout
        sendMessage.restart();
        if (myTransfer.available()) {
            // reset missing motor message count
            missedMotorMessageCount = 0;
            uint8_t recSize = 0;
            myTransfer.rxObj(motorSpeeds, sizeof(motorSpeeds), recSize);
        } else {
            missedMotorMessageCount++;
        }
    }
    // Have we missed 5 valid motor messages?
    if (missedMotorMessageCount >= 10) {
        motorSpeeds.left = 0;
        motorSpeeds.right = 0;
    }
#ifdef DEBUG
    Serial.print(motorSpeeds.left);
    Serial.print(' ');
    Serial.print(motorSpeeds.right);
    Serial.println();
#endif
    // Write motorspeeds
    motorLeft.writeMicroseconds(map(motorSpeeds.left, -100, 100, 1000, 2000));
    motorRight.writeMicroseconds(map(motorSpeeds.right * -1, -100, 100, 1000, 2000));

    if (readSensors.hasPassed(10)) {
        readSensors.restart();
        // Iterate through ToF sensors and attempt to get reading
        for (uint8_t t = 0; t < 8; t++) {
            tcaselect(t);
            if (activeToFSensors[t]) {
                distances[t] = sensor.readRangeContinuousMillimeters();
                if (sensor.timeoutOccurred()) {
                    distances[t] = 0;
#ifdef DEBUG
                    Serial.printf("TIMEOUT READING ToF %d", t);
#endif
                }
            } else {
                distances[t] = 0;
            }
        }
#ifdef DEBUG
        Serial.printf(
            "distances: %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f",
            distances[0],
            distances[1],
            distances[2],
            distances[3],
            distances[4],
            distances[5],
            distances[6],
            distances[7]);
        Serial.println();
#endif

        /// Read Encoder counts
        for (u_int8_t n = 0; n < NUM_ENCODERS; n++) {
            encoderReadings[n] = encoders[n].read();
        }

        uint16_t payloadSize = 0;

        // Prepare the distance data
        myTransfer.txObj(distances, sizeof(distances), payloadSize);
        payloadSize += sizeof(distances);

        //Prepare encoder data
        myTransfer.txObj(encoderReadings, sizeof(encoderReadings), payloadSize);
        payloadSize += sizeof(encoderReadings);

        // Send data
        myTransfer.sendData(payloadSize);
    }
}